https://www.jianshu.com/p/3ad37c93ad16+&cd=1&hl=zh-CN&ct=clnk&gl=jp

跟着白泽读paper丨Full-speed Fuzzing: Reducing Fuzzing Overhead through Coverage-guided Tracing
\color{red}{如需转载请注明出处，侵权必究。}

Full-speed Fuzzing: Reducing Fuzzing Overhead through Coverage-guided Tracing
论文链接：https://arxiv.org/abs/1812.11875?context=cs.CR

开源项目地址：https://github.com/FoRTE-Research/UnTracer-AFL

本文发表在IEEE Symposium on Security and Privacy 2019，作者是来自弗吉尼亚理工学院的研究团队。

1 主要内容

由覆盖引导的模糊测试技术是目前最有效的寻找软件bug的途径之一。代码覆盖追踪是该技术的一个重要组成部分，同时也是由覆盖引导的模糊测试的开销的主要来源。目前由覆盖引导的模糊测试技术会追踪所有测试用例的代码覆盖率，然而绝大部分的测试用例和他们的覆盖信息实际是无用的，因为他们并不会增加代码覆盖率。追踪这些无用的测试用例极大的增加了模糊测试工具的开销。

为了减少对这些无用测例的追踪以提高模糊测试的性能，本文的作者提出了一种由覆盖引导的追踪技术，来对过滤这些无用测例。该技术可以在不对测例进行追踪的情况下，检测出一个新生成的测例会不会引起代码覆盖率的增加，只有当新测例会引起代码覆盖率增加，才对该测例进行覆盖追踪，以获得完整的覆盖率信息。

基于覆盖引导的追踪技术，作者实现了一个工具UnTracer，并将其运用到其他流行的由覆盖引导的模糊测试工具中。在8个真实世界程序上的测试证明，该技术的使用能够大大降低由覆盖引导的模糊测试技术的开销。

2 设计与实现

上图是引入了由覆盖引导的追踪技术后，模糊测试工具的流程图。可以看到在原有代码覆盖追踪（标号2）之前引入了一个新的步骤 the interest oracle（标号1）。Interest Oracle的基本原理是，对于待模糊测试的目标二进制程序，在每一个未覆盖的基本块的开始处插入一个特殊的中断指令，生成一个新的程序。对于每一个新生成的测试用例，先在新的程序上运行，如果触发了该特殊的中断指令，说明这个测例到达了一个之前未到达过的基本块，因此这个测例会引起覆盖率的增加，是一个我们感兴趣的测例；如果没有触发中断，则说明这个输入到达的都是之前已经测试过的基本块，会被直接抛弃。只有当一个新的测例被确定是感兴趣的测例，才会被传递给后续模块进行真正的代码覆盖追踪（标号2）。代码覆盖追踪可以确定这个测例所到达的所有之前未到达的基本块，新程序中这些块头部的中断指令就会被移除（标号3）。

由覆盖引导的追踪技术使用了一个轻量的技术方案，来确定一个测例是否会到达新的基本块，增加代码覆盖率，避免对无效的测例进行覆盖追踪，从而提升整体的性能。

3 实验
本工作的实验主要比较了由覆盖引导的追踪技术和主流覆盖追踪技术的性能差异。作者选取了8个不同种类的真实世界程序作为测试集，比较用不同追踪技术运行测例，与直接运行测例相比，额外花费的时间。实验结果显示，在白盒测试场景下，作者提出的由覆盖引导的追踪技术只有0.3%额外开销，而覆盖追踪技术则有36%的额外开销。在黑盒测试场景下，由覆盖引导的追踪技术平均有20%的额外开销，而其他工具有500%-600%的额外开销。

4 总结
作者从模糊测试过程中，绝大部分生成的测试用例都无法增加代码覆盖率这一对现实的观察出发，选取了代码覆盖率追踪为切入点，使用了一种较为简单的技术，对由覆盖引导的模糊追踪技术进行优化，并且取得了不错的性能提升。但这种优化对由覆盖引导的模糊测试工具的效果的影响是未知的。比如在相同的运行时间下，引入由覆盖引导的追踪技术的模糊测试，能否比原来的工具获得更高的覆盖率，对于这类问题，本文并没有回答。

文 章 | Robin, Harry, BlackMax
